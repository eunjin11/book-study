# 01 실행 컨텍스트란?

**실행 컨텍스트**란?
> 실행할 코드에 제공할 환경에 대한 정보들을 담은 객체

### 자바스크립트는 코드 실행 과정
1. 실행할 **환경(컨텍스트)** 을 생성 
2. 변수, 함수, this, 스코프 체인 등을 초기화
	1. 변수, 함수 선언을 메모리에 미리 등록
3. 코드를 한 줄씩 실행하면서 **실행 컨텍스트를 갱신**
	1. 변수 값 할당, 함수 호출 등 수행

### 실행 컨텍스트의 종류

| 컨텍스트 종류          | 생성 시점               | 예시                |
| ---------------- | ------------------- | ----------------- |
| **전역 실행 컨텍스트**   | 자바스크립트 코드가 처음 실행될 때 | `index.js` 최상단 코드 |
| **함수 실행 컨텍스트**   | 함수가 호출될 때마다 생성      | `myFunc()`        |
| **eval 실행 컨텍스트** | `eval()` 호출 시 생성    | 거의 안 씀            |

동일한 환경에 있는 코드들을 실행할 때 필요한 환경 정보들을 모아 컨텍스트를 구성하고, 이를 콜 스택에 쌓아올렸다가, 가장 위에 쌓여있는 컨텍스트와 관련 있는 코드들을 실행 -> 코드의 환경과 순서를 보장

### 실행 컨텍스트 내부 구조

실행 컨텍스트는 크게 **3가지 주요 구성 요소**로 이루어져 있다.

| 구성 요소                    | 설명                                                          | 예시                |
| ------------------------ | ----------------------------------------------------------- | ----------------- |
| **Variable Environment** | 선언된 변수, 함수, 매개변수를 저장. Lexical Environment의 스냅샷으로 변경 사항 반영 x | `var`, `function` |
| **Lexical Environment**  | 식별자 → 값 매핑, 스코프 체인 관리                                       | `let`, `const`    |
| **This Binding**         | 식별자가 바라봐야 할 대상 객체                                           | `window` 또는 객체    |

---

# 02 VariableEnvironment

VariableEnvironment의 내용은 LexicalEnvironment와 같지만, 최초 실행 시의 스냅샷이며 이후 변경 사항이 반영되지 않는다는 점이 다르다.

실행 컨텍스트 생성 시 VariableEnvironment에 정보를 먼저 담고, 이를 복사해서 LexicalEnvironment를 만든다. 이 둘은 environmentRecord와 outer-EnvironmentReference로 구성되어 있다.

---

# 03 LexicalEnvironment

컨텍스트를 구성하는 환경 정보들

## environmentRecord와 호이스팅

environmentRecord에는 현재 컨텍스트와 관련된 코드의 식별자 정보들(컨텍스트를 구성하는 함수에 지정된 매개변수 식별자, 선언된 함수, var로 저장된 변수의 식별자 등)이 저장된다.
컨텍스트 내부 전체를 처음부터 훑으며 순서대로 수집한다.


> 전역 실행 컨텍스트는 자바스크립트 구동 환경이 별도로 제공하는 전역 객체(`window`, `global`, **ECMAScript 표준** 에서는 `globalThis`)을 활용한다.
> 이들은 자바스크립트 내장 객체가 아닌, 호스트 객체로 분류된다.

### 호스트 객체(Host Object)란?

**호스트 객체**란 **자바스크립트 엔진 외부에서, 실행 환경이 제공하는 객체**  
즉, **브라우저**나 **Node.js** 같은 **호스트 환경(host environment)** 이 제공하는 API들

| 구분             | 예시                                          | 제공 주체           |
| -------------- | ------------------------------------------- | --------------- |
| **브라우저 환경**    | `window`, `document`, `location`, `fetch` 등 | 브라우저            |
| **Node.js 환경** | `global`, `process`, `Buffer`, `require` 등  | Node.js         |
| **공통 표준화**     | `globalThis`                                | ECMAScript 2020 |
### 내장 객체(Built-in Object)와의 차이

**내장 객체(Built-in Object)** 는 어떤 실행 환경에서도 **자바스크립트 엔진이 기본적으로 제공하는 객체**

|종류|예시|제공 주체|
|---|---|---|
|**표준 내장 객체**|`Object`, `Array`, `Function`, `Date`, `Math`, `JSON` 등|ECMAScript|
|**비표준 호스트 객체**|`window`, `document`, `process` 등|브라우저/Node.js|

위 과정을 통해 코드 실행 이전에 코드의 변수명을 (위로 끌어올린 것 처럼) 모두 알게 된다. 이를 `호이스팅`이라고 한다.

---

## 호이스팅 규칙

### 호이스팅이란?

> 자바스크립트 엔진이 코드를 실행하기 전에 **변수 선언**과 **함수 선언**을 **해당 스코프의 최상단으로 끌어올린 것처럼 동작하는 현상**

**실행 컨텍스트 생성 단계**에서 변수와 함수가 메모리에 미리 등록되기 때문에, 끌어올려진 것 처럼 보인다.


```js
function a(x){ //parameter: x=1
	console.log(x)
	var x
	console.log(x)
	var x = 2
	console.log(x)
}
```

무엇이 출력될까?

arguments에 전달된 인자를 담는 것은 코드 내부에서 변수를 선언한 것과 같게 처리된다.
따라서 출력 결과는 var x; -> x=1 -> x=2로, 1, 1, 2가 출력된다.

```js
function a () {
	console.log(b);
	var b = 'bbb';
	console.log(b);
	function b () {}
	console.log(b)
}
```

무엇이 출력될까?

var b;와 function b가 호이스팅으로 인해 끌어올려진다. 이 때, 함수 선언은 전체가 끌어올려진다.
**호이스팅 순서:** 함수 선언문 → 변수 선언 → 변수 초기화이므로,
선언된 변수 b와 선언된 함수 b의 이름이 같으므로, 함수 b가 변수 b에 할당된다.
따라서 b 함수, bbb, bbb가 출력된다.

---

## 함수 선언문과 함수 표현식

### 함수 선언문
`function a() {}`

### 익명 함수 표현식
`var b = function() {}`

### 기명 함수 표현식
`var c = function d() {}`

이전에는 기명 함수 표현식이 디버깅에 유리했으나 현재는 모든 브라우저가 익명 함수 표현식의 변수명을 name 프로퍼티에 할당한다.

```js
function sum (a, b) {
	return a + b;
}

var multiply = function (a, b){
	return a * b
}
```

함수 선언문은 전체가 호이스팅 되지만, 함수 표현식은 그 변수의 선언부만 끌어올려진다.

```js
//호이스팅 결과
var sum = function sum (a, b){
	return a + b;
}

var multiply;

multiply = function (a, b){
	return a*b
}

```

무엇이 언제 어떻게 호이스팅 될 지 예측이 어렵기에... 함수 표현식이 안전하다.

---

## 스코프, 스코프 체인, outerEnvironmentReference

### 스코프란?

> 식별자에 대한 유효 범위

A 내부에서 선언한 변수는 A 내부에서만 접근할 수 있다.

자바스크립트에는 **전역 스코프(Global Scope)** 와 **지역 스코프(Local Scope)** 두 가지가 있다.

### (1) 전역 스코프

- 코드의 가장 바깥쪽에서 선언한 변수
- 프로그램 전체에서 접근 가능
- 브라우저에서는 `window`, Node.js에서는 `global`에 속한다.
    

```js
var globalVar = 'hello';
function foo() {
	console.log(globalVar);  // 접근 가능 
}
foo();
console.log(globalVar); // 접근 가능
```


---

### (2) 지역 스코프 (함수 스코프)

- 함수 내부에서 선언된 변수
- **함수 내부에서만 접근 가능**
- 바깥에서는 보이지 않음
    
```js
function bar() {
	var localVar = 'world';
	console.log(localVar); // 접근 가능 
}
bar();
console.log(localVar); // ReferenceError
```


### 렉시컬 스코프(Lexical Scope)

자바스크립트는 **렉시컬 스코프(정적 스코프)** 방식을 사용한다.

> **함수를 어디서 호출했는지가 아니라, 어디서 선언했는지**에 따라 스코프가 결정된다.

```js
var a = 'global';
function outer() {
	var a = 'outer';
	function inner() {
		console.log(a);
	}
	return inner;
}
const fn = outer();
fn(); // "outer"`
```

- `fn()`은 전역에서 실행됐지만, `inner()`는 **선언 당시**의 스코프(`outer`)를 기억함


### 스코프 체인이란?

> 식별자의 유효범위를 안에서부터 바깥으로 차례로 검색해나가는 것.
> 이를 가능하게 하는 것이 LexicalEnvironment의 두 번째 수집 자료인 outerEnvironmentReference이다.

(함수의) outerEnvironment는 선언될 당시의 LexicalEnvironment를 참조한다. 따라서 함수 내부에 함수를 선언하고 이가 반복될 경우 outerEnvironmentReference는 선언 시점의 LexicalEnvironment를 가까운 순대로 계속 찾아 올라가며... 연결 리스트처럼 연결된다.

가까운 요소부터 차례대로 접근하기에, 여러 스코프에서 동일한 식별자를 선언한 경우는 무조건 스코프 체인에서 가장 먼저 발견된 식별자에만 접근 가능하다.


### 변수 호이스팅 (var vs let vs const)

#### (1) var의 호이스팅

`var`는 선언과 동시에 **초기값 `undefined`** 까지 메모리에 등록된다.

```js
console.log(a); // undefined (에러 아님)
var a = 10;
console.log(a); // 10
```

**동작 원리**

1. 실행 컨텍스트 생성 시점 → `a` 변수를 메모리에 올림
2. 첫 번째 `console.log(a)` → 아직 값이 없으니 `undefined` 
3. 두 번째 `console.log(a)` → `a = 10` 할당 후 출력
    

---

#### (2) let과 const의 호이스팅

`let`과 `const`도 **호이스팅은 발생**하지만,  
`TDZ(Temporal Dead Zone, 일시적 사각지대)` 때문에 **초기화 전 접근 시 에러**가 발생

`console.log(b); // ReferenceError let b = 20;`

**동작 원리**

1. `b`는 실행 컨텍스트에 등록되지만, **초기화되기 전까지 접근 불가**
2. 변수 선언문 도달 시 값이 할당되고, 이후부터 정상 접근 가능

---

### 블록 스코프(Block Scope) vs 함수 스코프(Function Scope)

자바스크립트에서 `var`, `let`, `const`의 스코프 동작 방식이 다르다.

|선언 방식|스코프 유형|특징|
|---|---|---|
|**var**|함수 스코프|블록(`{}`) 무시, 함수 단위로만 스코프 생성|
|**let / const**|블록 스코프|`{}`를 기준으로 스코프 생성|

```js
if (true) {
	var a = 10;   let b = 20;
}  
console.log(a); // ✅ 10 (함수 스코프 → 밖에서도 접근 가능) 
console.log(b); // ❌ ReferenceError (블록 스코프)
```


# 05 정리

실행 컨텍스트 객체는 활성화되는 시점에 VariableEnvironment, LexicalEnvironment, ThisBinding의 세 가지 정보를 수집한다.
LexicalEnvironment는 VariableEnvironment를 복사해서 만든다. VariableEnvironment는 초기 상태를 유지하고 LexicalEnvironment는 변경 사항을 반영한다.

LexicalEnvironment는 매개변수명, 식별자, 함수명 등을 수집하는 environmentRecord와 직전의 LexicalEnvironment 정보를 참조하는 outerEnvironmentReference로 이루어져 있다.

호이스팅은 environmentRecord이 수집될 때 코드가 상단으로 끌어올려지는 것 처럼 보이는 것을 의미한다.
선언부만이 호이스팅되며 할당 과정은 제 자리에 남아있다. 이 때 함수 선언문은 함수 내용도 함께 끌어올려지지만 함수 표현식은 선언부만 끌어올려진다.

스코프는 변수의 유효 범위를 이야기하며, outerEnvironmentReference는 함수가 선언된 위치의 LexicalEnvironment를 계속하여 참조한다.

