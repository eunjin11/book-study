# 01 콜백 함수란?

> 다른 코드의 인자로 넘겨주는 함수
> 다른 함수의 인자로 전달되어, 그 함수 내부에서 실행되는 함수

함수 X를 호출하며 특정 조건에서 함수 Y를 실행해달라고 요청하는 것

## 콜백 함수의 특징

| 특징            | 설명                      |
| ------------- | ----------------------- |
| **1. 전달**     | 함수를 값으로 전달할 수 있음        |
| **2. 지연 실행**  | 즉시 실행되지 않고, 특정 시점에 실행됨  |
| **3. 제어권 위임** | 콜백을 넘겨받은 함수가 언제 실행할지 결정 |

# 02 제어권
## 호출 시점

setInterval이라고 하는 '다른 코드'에 첫 번째 인자로 콜백 함수를 넘겨주자, 제어권을 넘겨받은 setInterval이 스스로의 판단에 따라 두 번째 인자로 받은 시간마다 콜백 함수를 실행한다.
이처럼 콜백 함수의 제어권을 넘겨받은 코드는 콜백 함수 호출 시점에 대한 제어권을 가진다.

## 인자

map 메서드는 아래와 같은 구조로 이루어져있다.
```js
Array.prototype.map(callback[, thisArg])
callback: function(currentValue, index, array)
```

map 메서드는 첫 번째 인자로 callback 함수를 받고, 생략 가능한 두 번째 인자로 콜백 함수 내부에서 this로 인식할 대상을 특정할 수 있다. (생략 시 일반적인 함수처럼 전역 객체가 바인딩 된다.)

map 메서드는 배열의 모든 요소를 하나씩 꺼내어 콜백 함수를 호출하고, 콜백 함수의 결과를 모아 새로운 배열을 만든다.


## 동기(Synchronous) 콜백 vs 비동기(Asynchronous) 콜백

콜백 함수는 크게 **동기 콜백**과 **비동기 콜백**으로 나눌 수 있다.

### 1. 동기 콜백

> 함수를 **즉시 실행**하는 콜백

예를 들어 `Array.prototype.map`, `forEach`, `filter` 같은 메서드는 동기적으로 콜백을 실행한다.

```js
const numbers = [1, 2, 3];
const doubled = numbers.map(function (n) {   return n * 2; });  console.log(doubled); // [2, 4, 6]
```

### 2. 비동기 콜백

> 일정 시간이 지난 뒤 실행되거나, 특정 이벤트가 발생했을 때 실행되는 콜백

#### setTimeout

```js
console.log('시작');
setTimeout(() => {   console.log('2초 후 실행'); }, 2000);
console.log('끝');

```

#### 이벤트 리스너
```js
document.querySelector('#btn').addEventListener('click', function() {
  console.log('버튼 클릭됨!');
});

```

## this

콜백 함수도 함수이기에 기본적으로 this는 전역객체를 참조하지만, 별도로 this가 지정된 경우는 그 대상을 참조한다.
```js
element.addEventListener('click', function(e){
		console.log(this, e);
	}
)
```

addEventListner 내부에서 콜백 함수를 호출할 때 call 메서드의 첫 번째 인자에 addEventListener 메서드의 this를 그대로 넘기도록 정의되어 있기에 콜백 함수 내부에서의 this는 addEventListner을 호출한 주체인 HTML 엘리먼트를 가리키게 된다.


자바스크립트에서 `this`가 무엇을 참조할지는 **"함수가 어떻게 호출되었는가"** 에 따라 달라진다.

|호출 방식|예시|`this` 값|
|---|---|---|
|일반 함수 호출|`func()`|**전역 객체** (`window` 또는 `global`)|
|메서드 호출|`obj.method()`|**obj**|
|생성자 호출|`new Func()`|새로 생성된 객체|
|명시적 바인딩|`func.call(obj)`|`obj`|
|이벤트 핸들러|`element.addEventListener('click', callback)`|**이벤트를 바인딩한 요소**|
#### 일반 함수에서는?

```js
function normalCallback() {
  console.log(this);
}

normalCallback(); // 브라우저: window / Node: global. 전역 객체 참조
```

#### 이벤트리스너에서는?

```js
const button = document.querySelector('button');

button.addEventListener('click', function (e) {
  console.log(this); // button
});
```
여기서 `this`는 전역 객체가 아니라, **이벤트를 바인딩한 HTML 요소(button)** 를 참조

#### addEventListener 내부 동작 원리

브라우저의 `addEventListener`는 콜백을 단순히 `callback()`으로 호출하지 않고,  
**`callback.call(element, event)`** 형태로 호출한다.

```js
Element.prototype.addEventListener = function (eventType, callback) {
  const element = this; // addEventListener를 호출한 HTML 요소

  // 이벤트가 발생하면 브라우저가 이렇게 호출한다고 가정
  element._handleEvent = function (event) {
    callback.call(element, event); 
  };

  // 이벤트 등록
  registerEvent(eventType, element._handleEvent);
};

```

- `call` 메서드는 **첫 번째 인자로 전달한 객체**를 `this`로 바인딩한다.
- 즉, `callback.call(element, event)` → `callback` 함수 내부의 `this`는 `element`가 된다.

#### 화살표 함수와의 차이

콜백 함수를 **화살표 함수**로 작성하면 `this` 동작이 달라진다.

```js
button.addEventListener('click', (e) => {
  console.log(this); // button 아님, 상위 스코프의 this (기본적으로 window... 객체 내라면 객체)
});
```

- 화살표 함수는 **자신만의 this를 가지지 않는다.**
- 대신, **선언된 위치의 상위 스코프**에서 `this`를 가져온다.
- 만약 전역에서 작성했다면, `this`는 `window` 또는 `undefined`가 됨

# 03 콜백 함수는 함수다

콜백 함수로 어떤 객체의 메서드를 전달하더라도, 그 메서드는 메서드가 아닌 함수로 호출된다.
-> 따라서 함수 내부에서의 this도 메서드의 객체가 아닌 전역객체가 된다.

# 04 콜백 함수 내부의 this에 다른 값 바인딩하기

그래도 메서드를 전달할 때 this가 객체를 바라보게 하고 싶다면?
화살표 함수 (상위 스코프의 this를 바라보게 됨) 혹은 bind를 활용할 수 있다.

# 05 콜백 지옥과 비동기 제어

> **콜백 지옥**이란?
> 콜백 함수를 익명 함수로 전달하는 과정이 반복되어 들여쓰기가 깊어지는 현상

동기적인 코드: 현재 코드가 완료된 후 다음 코드를 실행
CPU 연산을 통해 즉시 처리 가능한 코드는 대부분 동기적인 코드이다.

함수 실행을 보류(setTimeout), 함수 실행을 대기 (addEventListner), 요청 및 응답 대기 (XMLHttpRequest) 등은 비동기적인 코드이다.

사용자->게시글->댓글->좋아요 순으로 데이터를 불러올 때 콜백 지옥이 발생할 수 있다.

```js
getUser(1, function (user) {
  console.log('사용자:', user);

  getPosts(user.id, function (posts) {
    console.log('게시글:', posts);

    getComments(posts[0].id, function (comments) {
      console.log('댓글:', comments);

      getLikes(comments[0].id, function (likes) {
        console.log('좋아요:', likes);
      });
    });
  });
});

```

## 콜백 지옥 해결하기
### 1. 기명함수로 변환
```js
function getUser(id, callback) {
  setTimeout(() => {
    console.log('getUser 실행 중...');

    const user = { id: id, name: 'Alice' };

    callback(user);
  }, 1000);
}

...

function handleLikes(likes) {
  console.log('좋아요:', likes);
}

function handleComments(comments) {
  console.log('댓글:', comments);
  getLikes(comments[0].id, handleLikes);
}

function handlePosts(posts) {
  console.log('게시글:', posts);
  getComments(posts[0].id, handleComments);
}

function handleUser(user) {
  console.log('사용자:', user);
  getPosts(user.id, handlePosts);
}

getUser(1, handleUser);
```
그러나 여전히 복잡하고, 흐름을 따라가기 어렵다.

### 2. Promise 사용 (ES6)
```js
function getUser(id) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (id === 1) {
        resolve({ id: 1, name: 'Alice' });
      } else {
        reject(new Error('사용자를 찾을 수 없습니다.'));
      }
    }, 1000);
  });
}

...

getUser(1)
  .then((user) => {
    console.log('사용자:', user);
    return getPosts(user.id);
  })
  .then((posts) => {
    console.log('게시글:', posts);
    return getComments(posts[0].id);
  })
  .then((comments) => {
    console.log('댓글:', comments);
    return getLikes(comments[0].id);
  })
  .then((likes) => {
    console.log('좋아요:', likes);
  })
  .catch((error) => {
    console.error('에러 발생:', error);
  });
```

내부에 resolve 또는 reject 함수를 호출하는 구문이 있을 경우 둘 중 하나가 실행되지 전까지는 then 혹은 catch가 실행되지 않는다.
-> 비동기 작업이 완료될 때 resolve나 reject를 호출하여 비동기 작업을 동기적으로 사용할 수 있다.

## 3. Generator 사용 (ES6)
```js
function* fetchDataGenerator() {
  const user = yield getUser(1);
  console.log("사용자:", user);

  const posts = yield getPosts(user.id);
  console.log("게시글:", posts);

  const comments = yield getComments(posts[0].id);
  console.log("댓글:", comments);

  const likes = yield getLikes(comments[0].id);
  console.log("좋아요:", likes);
}

var fetchData = fetchDataGenerator();
fetchData.next()

```

`*`가 붙은 함수가 Generator 함수이다. Generator 함수를 실행하면 Iterator이 반환되는데, 이는 next라는 메서드를 가지고 있고 next가 실행되면 yield에서 함수의 실행이 멈춘다. 

## 4. async await 사용 (ES2017) 
```js
async function fetchData() {
  try {
    const user = await getUser(1);
    console.log('사용자:', user);

    const posts = await getPosts(user.id);
    console.log('게시글:', posts);

    const comments = await getComments(posts[0].id);
    console.log('댓글:', comments);

    const likes = await getLikes(comments[0].id);
    console.log('좋아요:', likes);
  } catch (error) {
    console.error('에러 발생:', error);
  }
}

fetchData();

```

await 표기 시 뒤의 내용이 Promise로 자동 전환되고, resolve된 후에 다음으로 진행된다.

# 06 정리

- 콜백 함수는 다른 코드에 인자로 넘겨지며 제어권도 위임한다.
- 인자로 메서드를 전달하더라도 함수로 실행된다.
