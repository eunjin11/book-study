# 01 클로저의 의미 및 원리 이해

> **클로저란?**
> 어떤 함수가 내부 함수를 반환할 때 실행 컨텍스트 종료 이후에도 함수 내의 특정 변수가 사라지지 않고 계속하여 참조되는 현상

```js
var outer = function () {
    var a = 1;
    var inner = function () {
        return ++a;
    }
    return inner();
};
var outer2 = outer2();
console.log(outer());
```

inner의 실행 결과를 return 하므로, outer 함수의 실행 컨텍스트가 종료되었을 때 a 변수를 참조하는 대상이 없어진다.


```js
var outer = function () {
    var a = 1;
    var inner = function () {
        return ++a;
    }
    return inner;
};
var outer2 = outer()
console.log(outer2()) //2
console.log(outer2()) //3
```

inner 함수 자체를 반환하므로, outer 함수의 실행 컨텍스트가 종료되어도 outer2는 outer의 실행 결과인 inner 함수를 참조한다.

inner 함수는 outer 함수의 LexicalEnvironment에 저장된 변수 a에 접근하여 값을 반환한다.

### JS의 GC 방식

JS의 GC는 어떤 값을 참조하는 변수가 하나라도 있다면, 그 값은 수집하지 않는다.
outer 함수는 실행 종료 시점에 inner 함수를 반환하는데, outer 함수는 종료되어도 inner 함수는 outer2를 통해 호출될 가능성이 있기 때문에 -> 그 경우 outer 함수의 LexicalEnvironment가 필요하기 때문에 수집되지 않는다.

이렇게, 지역변수를 참조하는 내부함수가 외부로 전달될 경우만 GC에 수집되지 않는다.

## return 없이도 클로저가 발생하는 경우

### 1. 외부 객체(window)의 메서드(setTimeout)에 전달할 콜백 함수 내부에서 지역 변수 참조

```js
function delayedLog() {
  const message = "Hello, Closures!";

  setTimeout(function () {
    console.log(message); // 여기서 message 참조 → 클로저 발생
  }, 1000);
}

delayedLog();

```

1. `setTimeout`에 전달한 콜백 함수는 **1초 뒤**에 실행됨.
2. delayedLog 함수의 실행 컨텍스트는 이미 종료되었는데도 콜백 함수가 message를 참조 가능
	- **콜백 함수가 클로저를 생성**했기 때문
	
=> JavaScript 엔진은 **콜백 함수가 참조하는 변수 환경을 메모리에 유지**

### 2. 외부 객체(DOM)의 메서드(addEventListener)에 등록할 함수 내부에서 지역 변수 참조

```js
<button id="myButton">Click Me!</button>
<script>
  function setupClickHandler() {
    const countMessage = "버튼 클릭 횟수:"; 
    let count = 0;

    document.getElementById("myButton").addEventListener("click", function () {
      count++;
      console.log(`${countMessage} ${count}`); // 클로저 발생
    });
  }

  setupClickHandler();
</script>

```

1. `setupClickHandler()` 실행 시 `count`와 `countMessage`라는 지역 변수가 생성됨.
2. `addEventListener` 내부에서 전달한 콜백 함수가 `count`를 참조 → **클로저 생성**
3. 버튼을 클릭할 때마다 콜백 함수가 실행되지만, 이미 종료된 `setupClickHandler`의 지역 변수 `count`를 계속 기억하고 있어 카운트가 증가됨

# 02 클로저와 메모리 관리

식별에 참조형이 아닌 기본형 데이터 (null or undefined)를 할당하여 메모리 해제하기

```js
var outer = function () {
    var a = 1;
    var inner = function () {
        return ++a;
    }
    return inner;
};
var outer2 = outer()
console.log(outer2()) //2
console.log(outer2()) //3
outer = null
```

# 03 클로저 활용 사례

## 1. 콜백 함수 내부에서 외부 데이터를 사용하고자 할 때

```js
var alertFruitBuilder = function (fruit) {
  return function () {
    alert(fruit);
  };
};

li.addEventListener('click', alertFruitBuilder(fruit));
```

## 2. 접근 권한 제어(정보 은닉)

### 카운터 예제
```js
const makeCounter = function () {
  let privateCounter = 0;
  function changeBy(val) {
    privateCounter += val;
  }
  return {
    increment() {
      changeBy(1);
    },

    decrement() {
      changeBy(-1);
    },

    value() {
      return privateCounter;
    },
  };
};

const counter1 = makeCounter();
const counter2 = makeCounter();

console.log(counter1.value()); // 0.

counter1.increment();
console.log(counter1.value()); // 1.

counter1.decrement();
console.log(counter1.value()); // 0.
```

### 자동차 예제

```js
var createCar = function(){
	var fuel = Math.ceil(Math.random()*10+10); //연료
	var power = Math.ceil(Math.random()*3+2); //연비
	var moved = 0; //이동 거리
	
	var publicMembers = {
		get moved(){ return moved; },
		run: function(){
			var km = Math.ceil(Math.random()*6);
			var wasteFuel = km / power;
			fuel -= wasteFuel;
			mover += km;
		}
	}
	Object.freeze(publicMembers) // 객체 내용 변경 방지
	return publicMembers;
}
```

**클로저를 활용해 접근권한을 제어하는 방법**
1. 함수에서 지역변수 및 내부함수 등을 생성한다.
2. 외부에 접근권한을 주고자하는 대상들로 구성된 참조형 데이터(여럿일 때는 객체 혹은 배열, 하나일 때는 함수)를 return 한다.

return 된 변수들은 public member이 되고, return 되지 않은 변수들은 private member이 된다.

## 부분 적용 함수(partially applied function)

> n개의 인자를 받는 함수에 미리 m개의 인자만 넘겨 기억시켰다가, 나중에 (n-m)개의 인자를 넘기면 함수의 실행 결과를 얻을 수 있는 함수

### bind를 활용한 부분 적용 함수

```js
function multiply(a, b, c) {
  return a * b * c;
}

// 부분 적용 함수 생성
const doubleAndMultiply = multiply.bind(null, 2);

console.log(doubleAndMultiply(3, 4)); // 2 * 3 * 4 = 24
```

this를 변경하기에, 메서드에서는 사용하기 힘들다.

### bind 대신 클로저를 활용한 부분 적용 함수
```js
function multiply(a) {
  return function (b, c) {
    return a * b * c;
  };
}

const doubleAndMultiply = multiply(2);

console.log(doubleAndMultiply(3, 4)); // 24
```

## 클로저를 활용한 throttle / debounce 직접 구현하기

|방식|호출 횟수|특징|
|---|---|---|
|**디바운스**|마지막 이벤트 이후 1번|API 호출, 입력값 변경 감지에 유리|
|**스로틀**|일정 주기마다 실행|스크롤, 드래그, 마우스 무브에 유리|

### 1. 디바운스(Debounce)

> 이벤트가 연속해서 발생할 때 **마지막 이벤트만 처리**하는 방식

```js
function debounce(func, delay) {
  let timer;
  return function (...args) {
    clearTimeout(timer);
    timer = setTimeout(() => func(...args), delay);
    //timer = setTimeout(() => func.apply(this, args), delay);
  };
}

const debounce200 = debounce(200);

function handleMouseMove(e) {
  console.log(`마우스 좌표: X=${e.clientX}, Y=${e.clientY}`);
}

document.addEventListener("mousemove", debounce200(handleMouseMove));

```

### 2. 스로틀(Throttle)

> 이벤트가 연속해서 발생해도 **일정 주기마다 한 번씩만 실행**하는 방식

```js
function throttle(delay) {
  return function (func) {
    let last = 0;
    return function (...args) {
      const now = Date.now();
      if (now - last >= delay) {
        func(...args); //func.apply(this, args);
        last = now;
      }
    };
  };
}


// 300ms짜리 스로틀 함수 생성
const throttle300 = throttle(300);

const onScroll = throttle300(() => {
  console.log('스크롤 이벤트');
});

window.addEventListener('scroll', onScroll);

```

## 커링 함수

> 여러 개의 인자를 받는 함수를 하나의 인자만 받는 함수로 나눠서 순차적으로 호출할 수 있게 체인 형태로 구성한 것

### 일반 함수로 구현

 ```js
 function add(a, b, c) {
  return a + b + c;
}

console.log(add(1, 2, 3)); // 6
 ```


### 커링 함수로 구현

```js
function curryAdd(a) {
  return function(b) {
    return function(c) {
      return a + b + c;
    };
  };
}

console.log(curryAdd(1)(2)(3)); // 6
```

### 화살표 함수를 사용한 커링 함수로 구현(ES6)

```js
const curryAdd = a => b => c => a + b + c;
console.log(curryAdd(1)(2)(3)); // 6
```

### 장점

1. **부분 적용(partial application)** 가능
    - 일부 인자만 먼저 적용하고 나중에 나머지 인자를 적용할 수 있음
    - 마지막 호출로 실행 컨텍스트가 종료된 후에 한번에 GC에 수거됨
```js
    const add5 = curryAdd(2)(3); // 아직 c 안 넣음
    console.log(add5(4)); // 2 + 3 + 4 = 9
    ```
2. **함수 재사용성 증가**
    - 고차 함수처럼 함수를 조합하여 유연하게 사용

### 커링 함수+지연 실행

```js
// 커링 + 지연 실행 예제
const lazyAdd = a => b => c => () => {
  console.log('계산 시작!');
  return a + b + c;
};

// 사용 예
const step1 = lazyAdd(1);      // 아직 계산 안 됨
const step2 = step1(2);        // 아직 계산 안 됨
const step3 = step2(3);        // 아직 계산 안 됨

console.log('계산 준비 완료');

const result = step3();         // 이제 계산 수행
console.log('결과:', result);   // 6
```

# 04 정리

>**클로저란?**
   어떤 함수에서 선언한 변수를 참조하는 내부함수를 외부로 전달할 경우, 함수의 실행 컨텍스트가 종료된 후에도 해당 변수가 사라지지 않는 현상.

### 참고 자료

[함수 - JavaScript \| MDN](https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Functions#%ED%81%B4%EB%A1%9C%EC%A0%80)
[클로저 - JavaScript \| MDN](https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Closures)