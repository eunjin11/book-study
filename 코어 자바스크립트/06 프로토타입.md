자바스크립트는 프로토타입 기반 언어이다.

프로토타입 기반 언어에서는 클래스 기반 언어의 상속 대신 어떤 객체를 프로토타입으로 삼고 이를 참조하여 상속과 비슷한 효과를 얻는다.

```js
var instance = new Constructor();
```

```js
function Person(name, age) {
  this._name = name;
  this._age = age;
  this.sayHello = function() {
    console.log(`안녕! 나는 ${this._name}이야.`);
  };
}

// new로 호출 → 인스턴스 생성
const eunjin = new Person('은진', 24);

console.log(eunjin._name); // '은진'
console.log(eunjin._age);  // 24

eunjin.sayHello(); // '안녕! 나는 은진이야.'

```

`instance`는 `Constructor`(생성자 함수)로 만들어진 인스턴스이며, `instance.__proto__`는 `Constructor.prototype`을 참조한다.

`prototype`은 객체이며, `__proto__`역시 객체이다.

```js
Person.prototype.getName = function(){
	return this._name
}
```

`eunjin.__proto__`를 출력하면 getName()이 나온다.

<img width="309" height="131" alt="eunjin proto" src="https://github.com/user-attachments/assets/736a242a-6ac1-46d9-a05a-c01a986b378f" />

```js
Person.prototype === eunjin.__proto__
```

왜냐면 둘이 같은 프로퍼티를 참조하기 때문이다.


그러나 
```js
eunjin.__proto__.getName() //undefined
```
에서는 `undefined`가 출력되는데, `getName` 함수 내부의 this가 `eunjin`이 아닌 `eunjin.__proto__`가 되기 때문이다.
 `eunjin` 내에는 name이 있으나 `eunjin.__proto__` 내에는 name이 없기에 undefined가 출력된다.

```js
eunjin.getName() //은진
```
근데 이렇게 하면 또 원하는대로 잘 출력된다.

왜일까?
- JS는 메서드를 찾을 때 먼저 **인스턴스 자체**에서 찾는다.
- 없으면 **프로토타입 체인**(`__proto__`)을 따라 올라가서 찾는다.

- `getName` 함수 내부에서 `this`는 **호출한 객체**를 기준으로 결정됩니다.
    - 여기서는 `eunjin.getName()` → `this === eunjin`
- 따라서 `this._name` → `'은진'` 출력됨.

### arr 생성해보기

```js
var arr = [1,2];
console.dir(arr);
console.dir(Array);
```

<img width="511" height="368" alt="prototype 내부" src="https://github.com/user-attachments/assets/d7665a79-fe5a-4b70-9f3c-5bdaa45603e3" />

new Array로 인스턴스를 생성하든, 배열 리터럴을 생성하든 instance인 [1, 2]가 생성된다.
이 인스턴스의 `__proto__`는 Array의 `prototype`을 참조하는데, `__proto__`는 생략이 가능하므로 Array의 `prototype`에 있는 push, pop등을 호출할 수 있다.

그러나 `prototype`에 있지 않은 `from`, `isArray`등의 메서드는 사용이 불가하다.

## constructor 프로퍼티

생성자 함수의 프로퍼티인 `prototype` 객체 내부, 인스턴스의 `__proto__` 객체 내부 에는 `constructor`이라는 프로퍼티가 있다.
이는 생성자 함수 (자기 자신)을 참조한다.

```js
console.log(Person.prototype.constructor === Person); // true
console.log(eunjin.constructor === Person); // true
```

- `eunjin` → 인스턴스
- JS는 프로퍼티 검색 시 **인스턴스 →  proto  → 그 위 프로토타입** 순으로 찾음
- 따라서 `eunjin.constructor` → `eunjin.__proto__.constructor` → `Person`

> 인스턴스의 `constructor`는 사실 인스턴스가 속한 **프로토타입의 constructor**를 참조함

constructor을 통해 인스턴스가 어떤 생성자로 만들어졌는지 확인할 수 있다.

또한 기본형 리터럴 변수(number, string, boolean)을 제외하면 값을 바꿀 수 있다. 주의!


# 02 프로토타입 체인

### 메서드 오버라이드

>  **오버라이드(Override)**란?
    하위 객체에서 상위(프로토타입) 메서드나 속성을 덮어쓰는 것
    덮어쓴 속성이 있으면 체인을 따라 올라가지 않고 그 값을 사용

```js
function Person(name) {
  this.name = name;
}

Person.prototype.sayHello = function() {
  console.log(`안녕, 나는 ${this.name}이야.`);
};

const eunjin = new Person('은진');

// 기본 동작
eunjin.sayHello(); // 안녕, 나는 은진이야.

// 오버라이드
eunjin.sayHello = function() {
  console.log(`안녕! 나는 특별한 ${this.name}이야.`);
};

eunjin.sayHello(); // 안녕! 나는 특별한 은진이야.
```

기존 sayHello를 호출하고 싶으면 어떻게 해야할까?
### 프로토타입 메서드 직접 호출하기

**방법**: `Person.prototype.sayHello.call(eunjin)`

```js
// 프로토타입의 원래 메서드 호출 
Person.prototype.sayHello.call(eunjin);  // 출력: 안녕, 나는 은진이야.
```

- `call`을 사용해서 **this를 인스턴스로 바인딩**
- 이렇게 하면 오버라이드 이전 메서드도 호출 가능

## 프로토타입 체인

>  **프로토타입 체인**: 객체가 속성이나 메서드를 찾을 때,  
    **자신 → proto** → 그 위 프로토타입 순으로 탐색하는 구조

배열 리터럴의 `__proto__` 내에는 또다시 `__proto__`가 있다. 이는 객체의  `__proto__`와 동일한데, prototype의 객체가 '객체'이기 때문이다.

기본적으로 모든 객체의  `__proto__`에는 `Object.prototype`이 연결된다.

따라서 어떤 데이터의  `__proto__` 프로퍼티 내부에 다시  `__proto__` 프로퍼티가 있고, 이가 연쇄적으로 이어진 것을 **프로토타입 체인**이라고 하며, 체인을 따라가며 검색하는 것을 **프로토타입 체이닝**이라고 한다.

```js
function Animal() {}
Animal.prototype.walk = function() { console.log("걷는다"); }

function Dog(name) {
  this.name = name;
}

Dog.prototype = Object.create(Animal.prototype); // 체인 연결
Dog.prototype.constructor = Dog;
Dog.prototype.bark = function() { console.log("멍멍!"); }

const dog = new Dog('뽀삐');
dog.bark();  // Dog.prototype에서 찾음
dog.walk();  // Animal.prototype에서 찾음

```

> 생성자 함수도 함수이므로, Function 생성자 함수의 prototype과 연결된다.

## 객체 전용 메서드의 예외사항

어떤 생성자 함수이든, `prototype`은 반드시 객체이기 때문에`Object.prototype`이 언제나 프로토타입 체인의 최상단에 존재하게 된다.

배열, 함수, Date, 정규식, 사용자 정의 객체 등 **모든 객체는 결국 `Object.prototype`을 상속받는다.**

이때 Date, 정규식 드으이 다른 데이터 타입도 해당 메서드를 사용할 수 있기 때문에, 객체에서만 사용할 메서드는 다른 데이터 타입처럼 프로트타입 객체 안에 정의할 수 없다.
ex) `arr`에 `arr.keys()`를 호출하면 key가 없음 ㅜㅜ

-> 객체 전용 메서드들은 `Object.prototype`이 아닌 `Object`의 스태틱 메서드로 부여한다.

```js
//Object의 스태틱 메서드들
const obj = { a: 1, b: 2 };

console.log(Object.keys(obj));   // ['a', 'b']
console.log(Object.values(obj)); // [1, 2]
console.log(Object.entries(obj)); // [['a', 1], ['b', 2]]
```

`obj.keys()`가 안 되는 이유는 **`obj` 객체의 프로토타입 체인에 `keys` 메서드가 없기 때문**

## 다중 프로토타입 체인

유사배열객체에서 배열 메서드를 적용하는 방법: `call, aply`
직접 만든 유사배열객체에서 배열 메서드를 적용하기 위해 `유사배열객체.prototype`이 배열의 인스턴스를 바라보게 할 수 있다.
=> 두 단계 이상의 체인을 지니는 다중 프로토타입 체인도 가능하다.

# 정리

- 어떤 생성자 함수를 new 연산자와 함께 호출하면 새로운 인스턴스가 생성된다.
- 이 인스턴스에는 `__proto__`라는 프로퍼티가 자동으로 부여되는데, 이는 `Constructor`의 `prototype` 프로퍼티를 참조한다.
- `__proto__`는 생략 가능한 속성이므로, 인스턴스는 `Constructor.prototype`의 메서드를 자신의 것 처럼 호출할 수 있다.

- `Constructor.prototype`내에는 `constuctor`이라는 프로퍼티가 있는데, 이는 생성자 함수 자신을 가리킨다. 이를 통해 자신의 생성자 함수가 무엇인지 알 수 있다.

- `Object.prototype`에는 모든 데이터 타입에서 사용할 수 있는 범용적인 메서드만 있으며, 객체에서만 사용 가능한 메서드는 `Object` 생성자 함수에 스태틱 메서드로 존재한다.
