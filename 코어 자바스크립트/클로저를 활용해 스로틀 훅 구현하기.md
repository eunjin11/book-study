[스로틀 (Throttle) - MDN Web Docs 용어 사전: 웹 용어 정의 \| MDN](https://developer.mozilla.org/ko/docs/Glossary/Throttle)

### 스로틀이란?

>어떤 작업이 일정 주기로 실행되도록 하는 것

스크롤이나 마우스 드래그 등 짧은 시간에 대량의 이벤트가 발생할 경우, 스로틀을 이용해 이벤트가 과다하게 실행되는 것을 줄일 수 있다.

프로젝트를 하며 스크롤 이벤트 최적화를 이용해 공용 스로틀 훅을 만든 적이 있다.

이번에 코어 자바스크립트 책을 읽으며, 내가 만든 스로틀 훅에 클로저가 사용되었다는 것을 알게 되었다.
어떻게 사용되었을까?

```js
import { useCallback, useRef } from 'react';

function useThrottle<E>(func: (e: E) => void, delay: number): (e: E) => void {
  const lastTime = useRef(0);
  const timeoutRef = useRef<number | null>(null);

  return useCallback(
    (e: E) => {
      const now = Date.now();

      if (now - lastTime.current >= delay) {
        func(e);
        lastTime.current = now;
      } else {
        if (timeoutRef.current) clearTimeout(timeoutRef.current);

        timeoutRef.current = window.setTimeout(() => {
          func(e);
          lastTime.current = Date.now();
        }, delay - (now - lastTime.current));
      }
    },
    [func, delay]
  );
}

export default useThrottle;
```

`const lastTime = useRef(0);` 이 클로저로 캡처된다.

useCallback으로 return 되는 함수에서 lastTime의 값을 참조하여, lastTime이 지나기 전에만 func이 실행된다.

### 동작 과정

1. **즉시 실행 가능한 경우**
    - 현재 시간 `now`와 `lastTime.current`의 차이가 `delay` 이상이면, 바로 `func` 실행 → `lastTime` 갱신
        
2. **아직 딜레이가 안 지난 경우**
    - 실행을 지연시켜야 하므로 `setTimeout`을 걸어둠
    - 만약 기존에 예약된 `timeout`이 있으면 취소 (`clearTimeout`)
    - 새로운 타이머에서 `delay - 경과 시간` 뒤에 `func` 실행
    - 실행 후 `lastTime` 갱신

이런 플로우를 통해 동작한다.

## 스로틀의 구현 방식

스로틀의 구현 방식에는 두가지가 있다.

### 1. Leading Only 방식
- 일정 간격(`delay`)마다 **최대 1번만 실행**
- 추가 호출은 **무시**됨
단점: 마지막 이벤트 (드래그 후 좌표 적용)이 무시될 수 있음
### 2. Leading + Trailing 방식
- 즉시 실행이 안 될 때, **마지막 호출을 예약**
- 딜레이 후 마지막 이벤트까지 반영 가능
- **장점**: UI의 최종 상태 보장 (예: 드래그 마지막 위치 적용됨)
- **단점**: 불필요한 예약이 누적될 수 있음

두가지 방법이 있는데, UI의 최종 상태 보장이 중요하다고 생각해 Leading + Trailing 방식을 선택했다.
불필요한 예약이 누적될 수 있다는 단점이 있는데, `clearTimeout(timeoutRef)` 를 통해 불필요한 예약을 정리


## 개선하기

현재 코드에는 두가지 문제가 있다.

- `func`가 매번 새로 정의되면(`inline handler`) `useCallback` 의존성 때문에 매번 새로운 throttle 핸들러가 만들어진다.
- `timeoutRef`는 클리어하지 않고 컴포넌트가 언마운트되면, 간혹 **메모리 릭**이 생길 수 있다.

=> `func`도 보통 `useCallback`으로 감싸서 전달, `useEffect`로 `clearTimeout`을 cleanup하여 개선해보기로 했다.

### 개선된 코드

```js
import { useCallback, useEffect, useRef } from "react";

function useThrottle<E>(func: (e: E) => void, delay: number): (e: E) => void {
  const lastTime = useRef(0);
  const timeoutRef = useRef<number | null>(null);

  const **latestFunc** = useRef(func);
  useEffect(() => {
    latestFunc.current = func;
  }, [func]);

  const throttled = useCallback(
    (e: E) => {
      const now = Date.now();

      if (now - lastTime.current >= delay) {
        latestFunc.current(e);
        lastTime.current = now;
      } else {
        if (timeoutRef.current) clearTimeout(timeoutRef.current);

        timeoutRef.current = window.setTimeout(() => {
          latestFunc.current(e);
          lastTime.current = Date.now();
        }, delay - (now - lastTime.current));
      }
    },
    [delay]
  );

  useEffect(() => {
    return () => {
      if (timeoutRef.current) clearTimeout(timeoutRef.current);
    };
  }, []);

  return throttled;
}

export default useThrottle;
```

지금와서 드는 생각은... 이벤트를 위한 훅이니까 제네릭을 E로 설정했는데, 이벤트에만 사용 가능한 훅이 아니기에 E말고 T를 썼으면 더 좋았을 것 같다.

useThrottle 훅 구경하기
[Team1-ImSnacks/frontend/src/hooks/useThrottle.ts at main · softeerbootcamp-6th/Team1-ImSnacks · GitHub](https://github.com/softeerbootcamp-6th/Team1-ImSnacks/blob/main/frontend/src/hooks/useThrottle.ts)